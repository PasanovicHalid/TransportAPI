import argparse
import datetime
import os
import sys
import codecs

parser = argparse.ArgumentParser(description='Generate a MediatR command and Command handler for a specified name.')
parser.add_argument('base_path', type=str, help='The base path of the project.')
parser.add_argument('folder_path', type=str, help='The folder in which the command and command handler will be generated.')
parser.add_argument('type', type=str, help='Indicates the type of the command.')
parser.add_argument('name', type=str, help='The name of the command and command handler to generate.')
parser.add_argument('return_type', type=str, help='The return type of the command handler.')
parser.add_argument('fields', nargs='+', metavar='field:type', help='The fields and types of the command.')
args = parser.parse_args()

if not args.name.isidentifier():
    print('Invalid name. Please enter a valid identifier.')
    sys.exit()

project_name = args.base_path.split('\\')[-1]
folder_structure = args.folder_path.replace(args.base_path, '')

namespace = project_name + folder_structure.replace('\\', '.')
request_type = args.type
command_name = args.name + args.type
handler_name = args.name + args.type +'Handler'
validator_name = args.name + args.type + 'Validator'

if args.return_type == 'void':
    return_type = 'Result'
else:
    return_type = f'Result<{args.return_type}>'



fields = {}
for field in args.fields:
    name, type_ = field.split(':')
    fields[name] = type_

field_declarations = '\n'.join([f'\t\tpublic {type_} {name} {{ get; set; }}' for name, type_ in fields.items()])
validator_rules = '\n'.join([f'\t\t\tRuleFor(x => x.{name})\n\t\t\t\t.NotEmpty()\n\t\t\t\t.WithMessage("{name} is required");\n' for name in fields.keys()])
validator_rules = validator_rules[:-1]

code_template = f'''using MediatR;
using FluentResults;
using FluentValidation;
using System.Threading;
using System.Threading.Tasks;

namespace {namespace}
{{
    public sealed class {command_name} : I{args.type}<{return_type}>
    {{
{field_declarations}
    }}

    internal sealed class {validator_name} : AbstractValidator<{command_name}>
    {{
        public {validator_name}()
        {{
{validator_rules}
        }}
    }}

    internal sealed class {handler_name} : IRequestHandler<{command_name}, {return_type}>
    {{
        public async Task<{return_type}> Handle({command_name} request, CancellationToken cancellationToken)
        {{
            throw new NotImplementedException();
        }}
    }}
}}

'''

date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

if not os.path.exists(args.name):
    os.makedirs(args.name)

with codecs.open(f'{args.folder_path}/{command_name}.cs', 'w', 'utf-8') as f:
    #f.write(f'// Generated by Python script on {date}\n\n')
    f.write(code_template)

print(f'{command_name}.cs generated successfully!')